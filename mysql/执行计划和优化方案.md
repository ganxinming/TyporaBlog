#### 查看sql语句的执行：explain

 explain select * from tb_item ti join tb_item_desc td on ti.id=td.item_id  where ti.id like '153%';

![1554428348330](C:\Users\12714\AppData\Roaming\Typora\typora-user-images\1554428348330.png)

1.id值相同：查询顺序从上往下。（这个顺序可能会变，假如三张表，系统会按照最优方式选择排序查询，即连接数最小的方式，数量越大越在往后执行。）

2.select_type:该查询的类型

​			一：SIMPLE:简单查询，不包含子查询，union等。

​			二：PRIMARY:是一个包含子SQL查询的主查询。（最外层）

​			三：SUBQURY：包含子查询中的子查询（非最外层）

​			四：DERIVED:  衍生查询（组成临时表的，union等）

3.type（**索引类型,需要优化**）:从上到下，性能越来越好。

|  ALL              |  全表扫描 （无索引，无优化）

|  index            |  扫描全部索引树

|  range            |  扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、<、>等的查询    特殊:in有时候会失效 ，从而转为 无索引all)

|  ref                |  使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中

|  eq_ref           |  类似ref，区别在于使用的是唯一索引，使用主键的关联查询

|  const/system  |  单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询（一般达不到）

4.possible_keys：表示可能用到的索引（是一种预测，不准）

5.key（**需要优化**）：实际用到的索引。

6.key_len：表示索引长度。（mysql中，一个字符三个字节，比如char(20),那么长度就是60）

7.ref：指明当前表参照的是哪张表。

8.rows：查询的个数。

9.Extra:(**需要优化**)表示额外的做的事。

​						using filesort：性能消耗大，需要额外做一次排序。（常见于order by）

​						using temporary：性能消耗大，用到了临时表。（常见于group by）

​						using index：性能提升，覆盖索引。从索引文件就可以读到数据（不需要回表查询）

​						using where:需要会原表查询。

### 所以优化语句就可以根据上面的变量进行合适优化

# 优化：

### 单表优化：(in可能使索引失效)

##### 1.加索引。索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。根据SQL实际解析的顺序，调整索引的顺序。（就比如如果a in(1,2) and b=1;像这种含in的语句，前面的range也有讲，in可能会失效，索引类型转成all执行，所以，建立索引时，需将含in的索引放在最后面：如 index(b,a)）;

### 两表优化：

1.索引该放在哪个表上？ 放在数据量较少的表上。小表驱动大表 

select ...where 小表.x10=大表.x300 ;

select ...where 大表.x300=小表.x10 ;

2个FOR循环，最终都会循环3000次；但是 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内存，将数据量小的表 放左边（假设此时t表数据量小）[一般情况对于左外连接，给左表加索引；右外连接，给右表加索引]

### 三表优化：

a.小表驱动大表  b.索引建立在经常查询的字段上

i.如果 (a,b,c,d)复合索引  和使用的顺序全部一致(且不跨列使用)，则复合索引全部使用。如果部分一致(且不跨列使用)，则使用部分索引。

### 避免索引失效的一些原则 ：

1）复合索引
​	a.复合索引，不要跨列或无序使用（最佳左前缀）最好就是按照复合索引的顺序。

​	b.复合索引，尽量使用全索引匹配

​	c.使用索引不要使用表达式：不要：select ..where A.x*3 = .. ; （索引失效，机器识别不出来）

​	d.复合索引不能使用不等于（!=  <>）或is null (is not null)，否则自身以及右侧所有全部失效。
​		复合索引中如果有>，则自身和右侧索引全部失效。

-- SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。

like尽量以“常量”开头，不要以'%'开头，否则索引失效

尽量不要使用or，否则索引失效.

如果主查询的数据集大，则使用In   ,效率高。
如果子查询的数据集大，则使用exist,效率高。











