#### AQS:队列同步器，它是用来构建锁和其他同步组件的基础框架。是一个抽象类，只有方法没有实现，通过定义模板方法的方式提供了一套实现锁的模板，其最基本的锁实现方式需要子类复写模板：

内部：

/指向同步队列队头，Node为他的内部类
private transient volatile Node head;

//指向同步的队尾
private transient volatile Node tail;

//同步状态，0代表锁未被占用，1代表锁已被占用

private volatile int state;

state：表示当前锁状态，0表示没用，1表示有人占用了。

同步队列：采用双向链表的结构，便于对节点的操作。

注意head为空结点，不存储信息。

当进行lock(),加锁后，判断state的值是否为0，如果是，获得该锁，并将state置为1。如果不是，则将当前

### 线程封装成Node节点，加入同步队列。（**Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等**）

每个Node结点内部关联其前继结点prev和后继结点next，方便唤醒下一个线程。



#### 两种模式：独占锁或共享锁

所谓共享模式是一个锁允许多条线程同时操作，如信号量 Semaphore 采用的就是基于 AQS 的共享模式实现的

而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如 ReentranLock。

