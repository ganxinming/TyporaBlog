#### InnoDB和MyISAM区别：

1.默认支持事物(可重复读)，commit和rollback/不支持事物

2.支持行级锁(能并发/支持表级锁)/写的时候给整个表加锁

3.支持崩溃后恢复/不支持

4.支持外键(默认主索引:聚簇索引)/不支持外键

### MyISAM特性:

设计简单，数据以紧密格式存储，支持压缩表、空间数据索引。适用于读多写少的情况。

### InnoDB特性：

MVCC(多版本并发控制) 通过行级锁和版本号控制并发:在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

#### 类型：

整型:

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

浮点数:

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

字符串:

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

时间和日期：

dateTime:保存1000年到9999年的日期和时间，8字节。timestamp:只能表示从 1970 年到 2038 年。4字节。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

文本：

blob和text：BLOB能用来保存二进制数据，比如照片(不过一般不存照片)；而TEXT只能保存字符数据。必须指定索引前缀的长度

#### 数据量越来越大时：

水平切分：将同一个表中的记录拆分到多个相同表结构中。但是单独把表分离出来没啥意义，还在一个数据库里并没有缓解压力。此时应该分库，将分出来的表放置不同库中。

垂直切分:垂直切分是将一张表按列切分成多个表，通常是按照列的**关系密集程度**进行切分,相关联的在一起，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

读写分离(读从服务器，写主服务器)、主从复制:

使用前开启bin-log功能，日志文件用于记录数据库的读写增删

将一个数据库master复制到另一个slave数据库上。在Master和Slave之间实现整个主从复制的过程是由三个线程参与完成。

需要开启3个线程，master IO线程，slave开启 IO线程 SQL线程，
Slave 通过IO线程连接master，并且请求某个bin-log，position之后的内容。
MASTER服务器收到slave IO线程发来的日志请求信息，io线程去将bin-log内容，position返回给slave IO线程。
slave服务器收到bin-log日志内容，将bin-log日志内容写入relay-log中继日志，创建一个master.info的文件，该文件记录了master ip 用户名 密码 master bin-log名称，bin-log position。
slave端开启SQL线程，实时监控relay-log日志内容是否有更新，解析文件中的SQL语句，在slave数据库中去执行。

(总的来说就是，slave启动一个IO线程去读取master的binlog，master发现有人请求，则启动IO线程将文件发送给slave，之后slave启动sql线程relay-log(中继日志)，如果更新了执行里面的sql语句)

#### mysql优化：

1.不是使用子查询(使用关联查询)。底层会创建临时表，且该临时表没有索引，最后还得删除临时表，这样浪费太多时间了。

2.开启慢查询，优先优化那些查询慢的语句。

3.使用explain查看索引使用情况，表连接情况，扫描行数等。

4.表结构使用：是使用范式或者反范式结构。类型的选择

5.索引的优化，正确的建立合适的索引。

6.SQL语句的优化。

#### 主要索引优化：

作用：1.减少扫描量2.帮组避免排序和创建临时表3.使随机IO，变成顺序IO。

三星索引：1.相关记录在一起2.排序和查找顺序相同3.索引中列包含查询所有列。

1.索引字段建立在where之后。 索引个数不是越多越好，最好不要超过6个。索引应该建立在不经常变化的字段。

2.不要使用select *，可以用覆盖索引代替。

3.like的%加右边，左边容易失效。

4.最左前缀规则，假如abc，只能a,ab,abc，不能单独两列。

5.使用不等于（！= 或者<>）或者is null 或者 is not null 不能使用索引

6.对索引不要进行计算，不要对索引使用or。容易失效。



### sql语句题：

**复制表结构( 只复制结构, 源表名：a新表名：b)** 

1.create table   b   like a;

2.create table b select * from a  where limit 0 ;

**复制整个表**

create table b select * from a;

**拷贝表数据 ( 拷贝数据, 源表名：a目标表名：b)** 

 insert into b  select  *  from a; 

**三表连接**

select * from a left join  b on a.id=b.id left join c a.id=c.id;

##### 将一个表两列数据连接起来在一列

select concat (id, name, score) as info from tt2;

使用concat方法实现字符串拼接。默认是直接连接，可以加空格或逗号分开

select concat (id, ' ',name,',', score) as info from tt2;

##### mysql插入数据

insert into表示插入数据，数据库会检查主键（PrimaryKey），如果出现重复会报错；

replace into表示插入替换数据，需求表中有PrimaryKey，或者unique索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；（）

insert ignore  忽略数据库中已经存在 的数据，如果数据库没有数据，就插入新的数据



隔离级别的实现：

为什么需要隔离级别？在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

1.丢失修改:事物A修改数据，事物B修改数据覆盖A的修改。

2.脏读:事务A读到事务B未提交数据。

3.不可重复读:T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。可重复读是更改表中行级数据.

4.幻读:强调的是两次读到的数据的数量不一致。幻读是增加/减少表中行级数据

解决办法：

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| -------- | ---- | ---------- | ------ |
| 未提交读 | √    | √          | √      |
| 提交读   | ×    | √          | √      |
| 可重复读 | ×    | ×          | √      |
| 可串行化 | ×    | ×          | ×      |

那么这些隔离级别是怎么实现的？

两种方式：**悲观锁和乐观锁**

### 悲观锁：

在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现。往往依靠数据库提供的锁机制，读取数据时给加锁，其他事务无法改动这些数据。改动删除数据时也要加锁，其他事务无法读取这些数据。依靠读写锁来完成这些隔离级别。

#### 读写锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

| -     | X    | S    |
| ----- | ---- | ---- |
| **X** | ×    | ×    |
| **S** | ×    | √    |

通过三级封锁协议来达到目的：

**一级封锁协议**

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

**可以解决丢失修改问题**，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

**二级封锁协议**

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。(写数据时不能读数据)

**可以解决读脏数据问题**，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

**三级封锁协议**

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。(表示读数据时，不能加入x锁，所以读数据时就不能修改数据了)

**可以解决不可重复读的问题**，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

### 乐观锁：

相对悲观锁而言，乐观锁机制採取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销。特别是对长事务而言，这种开销往往无法承受。

而乐观锁机制在一定程度上攻克了这个问题。乐观锁，大多是基于数据版本号（ Version ）记录机制实现。何谓数据版本号？即为数据添加一个版本号标识，在基于数据库表的版本号解决方式中，通常是通过为数据库表添加一个 “version” 字段来实现。

即MVCC：用于实现提交读和可重复读这两种隔离级别。本身并不能解决幻读，而是通过next-key解决幻读(行级锁+间隙锁)。