#### InnoDB和MyISAM区别：

1.默认支持事物(可重复读)，commit和rollback/不支持事物

2.支持行级锁(能并发/支持表级锁)/写的时候给整个表加锁

3.支持崩溃后恢复/不支持

4.支持外键(默认主索引:聚簇索引)/不支持外键

### MyISAM特性:

设计简单，数据以紧密格式存储，支持压缩表、空间数据索引。适用于读多写少的情况。

### InnoDB特性：

MVCC(多版本并发控制) 通过行级锁和版本号控制并发:在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

#### 类型：

整型:

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

浮点数:

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

字符串:

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

时间和日期：

dateTime:保存1000年到9999年的日期和时间，8字节。timestamp:只能表示从 1970 年到 2038 年。4字节。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

文本：

blob和text：BLOB能用来保存二进制数据，比如照片(不过一般不存照片)；而TEXT只能保存字符数据。必须指定索引前缀的长度

#### 数据量越来越大时：

水平切分：将同一个表中的记录拆分到多个相同表结构中。但是单独把表分离出来没啥意义，还在一个数据库里并没有缓解压力。此时应该分库，将分出来的表放置不同库中。

垂直切分:垂直切分是将一张表按列切分成多个表，通常是按照列的**关系密集程度**进行切分,相关联的在一起，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

读写分离(读从服务器，写主服务器)、主从复制:

使用前开启bin-log功能，日志文件用于记录数据库的读写增删

将一个数据库master复制到另一个slave数据库上。在Master和Slave之间实现整个主从复制的过程是由三个线程参与完成。

需要开启3个线程，master IO线程，slave开启 IO线程 SQL线程，
Slave 通过IO线程连接master，并且请求某个bin-log，position之后的内容。
MASTER服务器收到slave IO线程发来的日志请求信息，io线程去将bin-log内容，position返回给slave IO线程。
slave服务器收到bin-log日志内容，将bin-log日志内容写入relay-log中继日志，创建一个master.info的文件，该文件记录了master ip 用户名 密码 master bin-log名称，bin-log position。
slave端开启SQL线程，实时监控relay-log日志内容是否有更新，解析文件中的SQL语句，在slave数据库中去执行。

(总的来说就是，slave启动一个IO线程去读取master的binlog，master发现有人请求，则启动IO线程将文件发送给slave，之后slave启动sql线程relay-log(中继日志)，如果更新了执行里面的sql语句)

#### mysql优化：

1.不是使用子查询(使用关联查询)。底层会创建临时表，且该临时表没有索引，最后还得删除临时表，这样浪费太多时间了。

2.开启慢查询，优先优化那些查询慢的语句。

3.使用explain查看索引使用情况，表连接情况，扫描行数等。

4.表结构使用：是使用范式或者反范式结构。类型的选择

5.索引的优化，正确的建立合适的索引。

6.SQL语句的优化。

#### 主要索引优化：

作用：1.减少扫描量2.帮组避免排序和创建临时表3.使随机IO，变成顺序IO。

三星索引：1.相关记录在一起2.排序和查找顺序相同3.索引中列包含查询所有列。

1.索引字段建立在where之后。 索引个数不是越多越好，最好不要超过6个。索引应该建立在不经常变化的字段。

2.不要使用select *，可以用覆盖索引代替。

3.like的%加右边，左边容易失效。

4.最左前缀规则，假如abc，只能a,ab,abc，不能单独两列。

5.使用不等于（！= 或者<>）或者is null 或者 is not null 不能使用索引

6.对索引不要进行计算，不要对索引使用or。容易失效。



### sql语句题：

**复制表结构( 只复制结构, 源表名：a新表名：b)** 

1.create table   b   like a;

2.create table b select * from a  where limit 0 ;

**复制整个表**

create table b select * from a;

**拷贝表数据 ( 拷贝数据, 源表名：a目标表名：b)** 

 insert into b  select  *  from a; 

**三表连接**

select * from a left join  b on a.id=b.id left join c a.id=c.id;

##### 将一个表两列数据连接起来在一列

select concat (id, name, score) as info from tt2;

使用concat方法实现字符串拼接。默认是直接连接，可以加空格或逗号分开

select concat (id, ' ',name,',', score) as info from tt2;

##### mysql插入数据

insert into表示插入数据，数据库会检查主键（PrimaryKey），如果出现重复会报错；

replace into表示插入替换数据，需求表中有PrimaryKey，或者unique索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；（）

insert ignore  忽略数据库中已经存在 的数据，如果数据库没有数据，就插入新的数据



隔离级别的实现：

为什么需要隔离级别？在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

1.丢失修改:事物A修改数据，事物B修改数据覆盖A的修改。

2.脏读:事务A读到事务B未提交数据。

3.不可重复读:T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。可重复读是更改表中行级数据.

4.幻读:强调的是两次读到的数据的数量不一致。幻读是增加/减少表中行级数据

解决办法：

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| -------- | ---- | ---------- | ------ |
| 未提交读 | √    | √          | √      |
| 提交读   | ×    | √          | √      |
| 可重复读 | ×    | ×          | √      |
| 可串行化 | ×    | ×          | ×      |

那么这些隔离级别是怎么实现的？

两种方式：**悲观锁和乐观锁**

### 悲观锁：

在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现。往往依靠数据库提供的锁机制，读取数据时给加锁，其他事务无法改动这些数据。改动删除数据时也要加锁，其他事务无法读取这些数据。依靠读写锁来完成这些隔离级别。

#### 读写锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

| -     | X    | S    |
| ----- | ---- | ---- |
| **X** | ×    | ×    |
| **S** | ×    | √    |

通过三级封锁协议来达到目的：

**一级封锁协议**

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

**可以解决丢失修改问题**，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

**二级封锁协议**

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。(写数据时不能读数据)

**可以解决读脏数据问题**，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

**三级封锁协议**

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。(表示读数据时，不能加入x锁，所以读数据时就不能修改数据了)

**可以解决不可重复读的问题**，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

### 乐观锁：

相对悲观锁而言，乐观锁机制採取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销。特别是对长事务而言，这种开销往往无法承受。

而乐观锁机制在一定程度上攻克了这个问题。乐观锁，大多是基于数据版本号（ Version ）记录机制实现。何谓数据版本号？即为数据添加一个版本号标识，在基于数据库表的版本号解决方式中，通常是通过为数据库表添加一个 “version” 字段来实现。

即MVCC：用于实现提交读和可重复读这两种隔离级别。本身并不能解决幻读，而是通过next-key解决幻读(行级锁+间隙锁)。

### 磁盘中的结构：

所有数据存放在data目录下:

库名/包含表结构文件，表结构包含.frm+索引结构.ibd(innodb) 或者.myd.myi(myISAM)

数据并不是和表结构放在一起，InnoDB 类型的表数据统一存放于 data 目录下的 **ibdata1** 文件中

（因为innodb是共享表空间的，所以存在一起。如果不想共享可以使用独享空间，只有独享空间会生成.ibd文件。）

（实际上ibata1是存放innodb索引结构的地方，但是由于innodb默认是聚簇索引

​	ibd是表空间的数据文件，以段区页方式规划存储数据行和索引)

1. 聚簇索引并不是一种单独的索引类型，而是一种数据数据存储方式；

2. 当表有聚簇索引是，它的数据行实际上存在放在索引的叶子页(leaf page)中；

3. 叶子页包含了行的全部数据；

   **所以在mysql中数据始终和索引放在一块，并不存在什么光存数据的地方。即使没有索引，也还是可以，别忘了聚簇索引说的：没有主键也能随机取或帮我们创建**

### Mysql如何实现ACID特性：

**原子性**：利用回滚的机制完成恢复到未执行事务之前。通过**Undo log**日志实现恢复。为了满足原子性，在做任何操作之前，首先将数据备份到undo log中。然后才开始事务，完成对数据操作。如果进行回滚，则将undo log日志恢复到之前的状态。

**持久性**：执行完事务操作，数据保存在数据库中。那他怎么保证事务操作后，数据一定保存在数据库。使用redolog。

**重做日志** redo log 分为两部分：一部分是内存中的重做日志缓冲（redo log buffer），是易丢失的；二部分是重做日志文件（redo log file），是持久的。InnoDB通过Force Log at Commit机制来实现持久性，当commit时，必须先将事务的所有日志写到重做日志文件进行持久化，待commit操作完成才算完成。

(将事务操作过程记录在缓冲中，待提交commit时，将缓冲写入到redo file中进行持久化)

**隔离性：**锁，MVCC等

**一致性：**undo log+redo log保证事务的一致性。

#### redo是物理逻辑日志，记录的是页的物理修改(提交前记录数据的修改，整个数据)操作。undo是逻辑日志，根据每行记录进行记录(记录每一步步骤，好回滚)。



**InnoDB 中的锁**

InnoDB 的标准实现的锁只有 2 类，一种是行级锁，一种是意向锁。

共享锁（读锁 S Lock），允许事务读一行数据。

排它锁（写锁 X Lock），允许事务删除一行数据或者更新一行数据。

意向共享锁（读锁 IS Lock），事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。

意向排他锁（写锁 IX Lock），事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排它锁前必须先取得该表的 IX 锁。

InnoDB 有 3 种行锁的算法：

- Record Lock：单个行记录上的锁。
- Gap Lock：间隙锁，锁定一个范围，而非记录本身。
- Next-Key Lock：结合 Gap Lock 和 Record Lock，锁定一个范围，并且锁定记录本身。主要解决的问题是 RR 隔离级别下的幻读。

#### 隔离级别：

**Serializable(串行化)**：强制事务排序，串行化执行事务。

**Repeatable Read(可重复读)**：解决不可重复读。啥叫不可重复读，即在一个事务里，读了两次数据，但是两次数据都不一致。可重复读则是保证可以重复读，而数据不会出错。利用MVCC进行版本控制。

MVCC：维持两个版本号，创建版本号和删除版本号(还有个系统版本号，可以认为是最近操作的事务版本号)

1.insert:插入一条新数据，创建版本号=原系统版本号+1（即当前事务的版本号）；

2.delete:删除一条数据，删除版本号=原系统版本号+1（即当前事务的版本号）；

3.select:查询只能查询出<=当前事务版本号的数，和删除版本>当前事务版本号或删除版本不存在的(即未删除).

4.update:开始就在想，如果第一个事务开始查询数据版本号为5，如果update了，此时版本号为6了，那么怎么可能select到呢？当然从开始这样想就错了。其实自己就没仔细考虑update这个动作，update如果是在原有基础上直接更改版本号，那么就会导致该数据被当前查询不到，显然不是这样有漏洞。

update正确做法：1.首先删除数据,删除版本号更新(这个并不影响上个事务查询)。2.插入一条新数据(更新为当前版本号)。所以此时数据库是有两条数据的，可能会在事务结束时才去删除带有删除版本号的数据。

**Read Committed(读已提交)**：解决脏读：避免读取到别人未提交的数据。mvcc默认解决这个问题，未提交数据版本号未更新。

**Read Uncommitted(读未提交)**：事务中的修改，即使没有提交，对其他事务也都是可见的。



in和exists区别:

exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率.当 exists( 查询 )中的查询存在结果时则返回真， 否则返回假。

in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率.s

#### (总结:则子查询表大的用exists，子查询表小的用in.

#### in是在内存里遍历比较，而exists需要查询数据库，所以当B表数据量较大时，exists效率优于in。)

in的优化：

sql:表连接真的有效，使用join代替in。记住结果集使用 (别名.*) ,如果全部显示，速度很慢。
(说白了还是显示时只显示有用数据。)

java代码:比较好的两个方法:1.使用线程池，多线程处理list集合。2.lambda表达式流的处理(本质也是多线程)



#### 1.添加索引:(格式:alter table name add 索引方法名(列名))

**1.添加PRIMARY KEY（主键索引）** 

mysql>ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 

**2.添加UNIQUE(唯一索引)** 
mysql>ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 

**3.添加INDEX(普通索引)** 

mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column` ) 

**4.添加FULLTEXT(全文索引)** 

mysql>ALTER TABLE `table_name` ADD FULLTEXT ( `column`)  

**5.添加多列索引** 
mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )



建立索引原则:(索引建立需要查询的字段)

1.保证唯一性。(如果不是唯一的，也可以建立普通索引，但是基本没啥效果。像之前的查询的username就是重复的)

2.限制索引数目，不能过多。

3.最左前缀，a，ab，abc(头到尾，中间不能断)

4.索引不能进行计算。

5.经常查询的字段，需要排序，分组的字段建立索引。

6.选择度尽量大。去重字段/总数据 ，唯一索引选择度是1。

(总结:使用explain观察语句时，发现没有使用索引，可能是本身就没有建立索引。此时，建立索引时就需要考虑索引的原则了)

sql执行顺序:

1、 FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。
2、 ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。(因为表连接当然得先查询条件啊)
3、 OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。
4、 WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。
5、 GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。
6、 CUTE|ROLLUP：把超组插入 VT5，生成 VT6。
7、 HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。
8、 SELECT：处理 SELECT 列表，产生 VT8。
9、 DISTINCT：将重复的行从 VT8 中删除，产品 VT9。
10、 ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。
11、 TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。

(on和where区别，on是表连接条件。where就是最后结果的筛选)



#### 今天在使用Navicat for mysql设计表时，在设置外键的时候，删除时和更新时两列有四个值可以选择：CASCADE、NO ACTION、RESTRICT、SET NULL，自己全亲自试了一遍，它们的区别如下：

##### (主表:其中存在主键(primary key)用于与其它表相关联，并且作为在主表中的唯一性标识)

##### (从表：以主表的主键(primary key)值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询)

CASCADE：父表delete、update的时候，子表会delete、update掉关联记录;(所以当删除主表时，从表也删除)
SET NULL：父表delete、update的时候，子表会将关联记录的外键字段所在列设为null，所以注意在设计子表时外键不能设为not null；
RESTRICT：如果想要删除父表的记录时，而在子表中有关联该父表的记录，则不允许删除父表中的记录；
NO ACTION：同 RESTRICT，也是首先先检查外键；

